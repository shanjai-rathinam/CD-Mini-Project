#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include <string>
#include <vector>
#include <unordered_map>
#include <stdexcept>

/**
 * @struct Instruction
 * @brief A simple representation of a single line of parsed assembly code.
 * This can be used for more complex assemblers but is not strictly necessary
 * for this simple two-pass implementation where we re-parse the file.
 */
struct Instruction {
    std::string label;
    std::string mnemonic;
    std::vector<std::string> operands;
    long address; // The address of this instruction
};

/**
 * @typedef SymbolTable
 * @brief A hash map to store labels and their corresponding memory addresses.
 * The key is the label name (std::string) and the value is its address (long).
 */
using SymbolTable = std::unordered_map<std::string, long>;

// --- Function Prototypes ---

/**
 * @brief Executes the first pass of the assembler.
 *
 * Reads the assembly source file, builds a symbol table containing all labels
 * and their calculated memory addresses, but does not generate any machine code.
 *
 * @param input_filename The path to the assembly source file (.asm).
 * @return A complete SymbolTable for the given source file.
 * @throw std::runtime_error if the input file cannot be opened or if a
 *        duplicate label is found.
 */
SymbolTable pass1(const std::string& input_filename);

/**
 * @brief Executes the second pass of the assembler.
 *
 * Reads the assembly source file again, translates each instruction into
 * machine code using the provided symbol table to resolve label addresses,
 * and writes the final output to an ELF object file.
 *
 * @param input_filename The path to the assembly source file (.asm).
 * @param output_filename The path where the output object file (.o) will be created.
 * @param symtab The symbol table generated by pass1.
 * @throw std::runtime_error if the input file cannot be opened or if an
 *        undefined label is referenced.
 */
void pass2(const std::string& input_filename, const std::string& output_filename, const SymbolTable& symtab);

#endif // ASSEMBLER_H
